{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"niceSmartCRM API Documentation","text":""},{"location":"#crm.crm_cmd","title":"<code>crm_cmd</code>","text":"<p>Created on 2024-01-12</p> <p>@author: wf</p>"},{"location":"#crm.crm_cmd.CrmCmd","title":"<code>CrmCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>Command line for Customer Relationship Management</p> Source code in <code>crm/crm_cmd.py</code> <pre><code>class CrmCmd(WebserverCmd):\n    \"\"\"\n    Command line for Customer Relationship Management\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"-v\",\n            \"--verbose\",\n            action=\"store_true\",\n            help=\"show verbose output [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-rp\",\n            \"--root_path\",\n            default=CRM.root_path(),\n            help=\"path to example dcm definition files [default: %(default)s]\",\n        )\n        return parser\n</code></pre>"},{"location":"#crm.crm_cmd.CrmCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>crm/crm_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"show verbose output [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-rp\",\n        \"--root_path\",\n        default=CRM.root_path(),\n        help=\"path to example dcm definition files [default: %(default)s]\",\n    )\n    return parser\n</code></pre>"},{"location":"#crm.crm_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>crm/crm_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = CrmCmd(\n        config=CrmWebServer.get_config(),\n        webserver_cls=CrmWebServer,\n    )\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#crm.crm_core","title":"<code>crm_core</code>","text":"<p>Created on 2024-01-12</p> <p>@author: wf</p>"},{"location":"#crm.crm_core.Organizations","title":"<code>Organizations</code>","text":"<p>               Bases: <code>EntityManager</code></p> <p>get organizations</p> Source code in <code>crm/crm_core.py</code> <pre><code>class Organizations(EntityManager):\n    \"\"\"\n    get organizations\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(entity_name=\"Organisation\")\n\n    def from_smartcrm(self, smartcrm_org_lod: List[Dict]) -&gt; List[Dict]:\n        \"\"\"\n        Convert a list of organizations from the smartcrm_org_lod format to a list of dictionaries\n        with appropriate field names and types.\n\n        Args:\n            smartcrm_org_lod (List[Dict]): List of organizations in smartcrm_org_lod format.\n\n        Returns:\n            List[Dict]: A list of dictionaries with converted field names and types.\n        \"\"\"\n        org_list = []\n        for org in smartcrm_org_lod:\n            converted_org = {\n                \"kind\": org.get(\"art\"),\n                \"industry\": org.get(\"Branche\"),\n                \"created_at\": self._convert_to_datetime(org.get(\"createdAt\")),\n                \"data_origin\": org.get(\"DatenHerkunft\"),\n                \"created_by\": org.get(\"ErstelltVon\"),\n                \"country\": org.get(\"Land\"),\n                \"last_modified\": self._convert_to_datetime(org.get(\"lastModified\")),\n                \"logo\": org.get(\"logo\", \"\"),\n                \"employee_count\": self._convert_to_int(org.get(\"Mitarbeiterzahl\")),\n                \"organization_number\": org.get(\"OrganisationNummer\"),\n                \"city\": org.get(\"Ort\"),\n                \"postal_code\": org.get(\"PLZ\"),\n                \"po_box\": org.get(\"Postfach\"),\n                \"sales_estimate\": self._convert_to_int(org.get(\"salesEstimate\")),\n                \"sales_rank\": self._convert_to_int(org.get(\"salesRank\")),\n                \"location_name\": org.get(\"Standort\"),\n                \"phone\": org.get(\"Telefon\"),\n                \"revenue\": self._convert_to_int(org.get(\"Umsatz\")),\n                \"revenue_probability\": self._convert_to_int(\n                    org.get(\"UmsatzWahrscheinlichkeit\")\n                ),\n                \"revenue_potential\": self._convert_to_int(org.get(\"Umsatzpotential\")),\n                \"country_dialing_code\": org.get(\"VorwahlLand\"),\n                \"city_dialing_code\": org.get(\"VorwahlOrt\"),\n                \"website\": org.get(\"Web\"),\n                \"importance\": org.get(\"Wichtigkeit\"),\n            }\n            org_list.append(converted_org)\n        return org_list\n</code></pre>"},{"location":"#crm.crm_core.Organizations.from_smartcrm","title":"<code>from_smartcrm(smartcrm_org_lod)</code>","text":"<p>Convert a list of organizations from the smartcrm_org_lod format to a list of dictionaries with appropriate field names and types.</p> <p>Parameters:</p> Name Type Description Default <code>smartcrm_org_lod</code> <code>List[Dict]</code> <p>List of organizations in smartcrm_org_lod format.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of dictionaries with converted field names and types.</p> Source code in <code>crm/crm_core.py</code> <pre><code>def from_smartcrm(self, smartcrm_org_lod: List[Dict]) -&gt; List[Dict]:\n    \"\"\"\n    Convert a list of organizations from the smartcrm_org_lod format to a list of dictionaries\n    with appropriate field names and types.\n\n    Args:\n        smartcrm_org_lod (List[Dict]): List of organizations in smartcrm_org_lod format.\n\n    Returns:\n        List[Dict]: A list of dictionaries with converted field names and types.\n    \"\"\"\n    org_list = []\n    for org in smartcrm_org_lod:\n        converted_org = {\n            \"kind\": org.get(\"art\"),\n            \"industry\": org.get(\"Branche\"),\n            \"created_at\": self._convert_to_datetime(org.get(\"createdAt\")),\n            \"data_origin\": org.get(\"DatenHerkunft\"),\n            \"created_by\": org.get(\"ErstelltVon\"),\n            \"country\": org.get(\"Land\"),\n            \"last_modified\": self._convert_to_datetime(org.get(\"lastModified\")),\n            \"logo\": org.get(\"logo\", \"\"),\n            \"employee_count\": self._convert_to_int(org.get(\"Mitarbeiterzahl\")),\n            \"organization_number\": org.get(\"OrganisationNummer\"),\n            \"city\": org.get(\"Ort\"),\n            \"postal_code\": org.get(\"PLZ\"),\n            \"po_box\": org.get(\"Postfach\"),\n            \"sales_estimate\": self._convert_to_int(org.get(\"salesEstimate\")),\n            \"sales_rank\": self._convert_to_int(org.get(\"salesRank\")),\n            \"location_name\": org.get(\"Standort\"),\n            \"phone\": org.get(\"Telefon\"),\n            \"revenue\": self._convert_to_int(org.get(\"Umsatz\")),\n            \"revenue_probability\": self._convert_to_int(\n                org.get(\"UmsatzWahrscheinlichkeit\")\n            ),\n            \"revenue_potential\": self._convert_to_int(org.get(\"Umsatzpotential\")),\n            \"country_dialing_code\": org.get(\"VorwahlLand\"),\n            \"city_dialing_code\": org.get(\"VorwahlOrt\"),\n            \"website\": org.get(\"Web\"),\n            \"importance\": org.get(\"Wichtigkeit\"),\n        }\n        org_list.append(converted_org)\n    return org_list\n</code></pre>"},{"location":"#crm.db","title":"<code>db</code>","text":"<p>Created on 2024-01-13</p> <p>@author: wf</p>"},{"location":"#crm.db.DB","title":"<code>DB</code>","text":"<p>Database wrapper for managing direct database connections and executing queries using PyMySQL.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>Dict[str, Any]</code> <p>Database configuration details.</p> <code>connection</code> <code>Connection</code> <p>PyMySQL connection instance.</p> Source code in <code>crm/db.py</code> <pre><code>class DB:\n    \"\"\"\n    Database wrapper for managing direct database connections and executing queries using PyMySQL.\n\n    Attributes:\n        config (Dict[str, Any]): Database configuration details.\n        connection (pymysql.connections.Connection): PyMySQL connection instance.\n    \"\"\"\n\n    def __init__(self, config_path: str = None):\n        \"\"\"\n        Initializes the database connection using provided configuration.\n\n        Args:\n            config_path (str, optional): Path to the configuration YAML file.\n                                         Defaults to '~/.smartcrm/db_config.yaml'.\n        \"\"\"\n        if config_path is None:\n            config_path = f\"{Path.home()}/.smartcrm/db_config.yaml\"\n        self.config = self.load_config(config_path)\n        self.connection = self.create_connection()\n\n    def load_config(self, path: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Loads the database configuration from a YAML file.\n\n        Args:\n            path (str): The file path of the YAML configuration file.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing database configuration.\n        \"\"\"\n        with open(path, \"r\") as file:\n            return yaml.safe_load(file)[\"database\"]\n\n    def create_connection(self) -&gt; pymysql.connections.Connection:\n        \"\"\"\n        Creates a PyMySQL connection using the loaded configuration.\n\n        Returns:\n            pymysql.connections.Connection: PyMySQL connection instance.\n        \"\"\"\n        config = {\n            \"host\": self.config[\"host\"],\n            \"user\": self.config[\"user\"],\n            \"password\": self.config[\"password\"],\n            \"db\": self.config[\"name\"],\n            \"charset\": \"utf8mb4\",\n            \"cursorclass\": pymysql.cursors.DictCursor,\n        }\n        return pymysql.connect(**config)\n\n    def execute_query(self, query: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Executes a SQL query and returns the results.\n\n        Args:\n            query (str): The SQL query to execute.\n\n        Returns:\n            List[Dict[str, Any]]: The result of the SQL query execution.\n        \"\"\"\n        with self.connection.cursor() as cursor:\n            cursor.execute(query)\n            return cursor.fetchall()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n</code></pre>"},{"location":"#crm.db.DB.__init__","title":"<code>__init__(config_path=None)</code>","text":"<p>Initializes the database connection using provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>Path to the configuration YAML file.                          Defaults to '~/.smartcrm/db_config.yaml'.</p> <code>None</code> Source code in <code>crm/db.py</code> <pre><code>def __init__(self, config_path: str = None):\n    \"\"\"\n    Initializes the database connection using provided configuration.\n\n    Args:\n        config_path (str, optional): Path to the configuration YAML file.\n                                     Defaults to '~/.smartcrm/db_config.yaml'.\n    \"\"\"\n    if config_path is None:\n        config_path = f\"{Path.home()}/.smartcrm/db_config.yaml\"\n    self.config = self.load_config(config_path)\n    self.connection = self.create_connection()\n</code></pre>"},{"location":"#crm.db.DB.close","title":"<code>close()</code>","text":"<p>Closes the database connection.</p> Source code in <code>crm/db.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the database connection.\n    \"\"\"\n    if self.connection:\n        self.connection.close()\n</code></pre>"},{"location":"#crm.db.DB.create_connection","title":"<code>create_connection()</code>","text":"<p>Creates a PyMySQL connection using the loaded configuration.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>pymysql.connections.Connection: PyMySQL connection instance.</p> Source code in <code>crm/db.py</code> <pre><code>def create_connection(self) -&gt; pymysql.connections.Connection:\n    \"\"\"\n    Creates a PyMySQL connection using the loaded configuration.\n\n    Returns:\n        pymysql.connections.Connection: PyMySQL connection instance.\n    \"\"\"\n    config = {\n        \"host\": self.config[\"host\"],\n        \"user\": self.config[\"user\"],\n        \"password\": self.config[\"password\"],\n        \"db\": self.config[\"name\"],\n        \"charset\": \"utf8mb4\",\n        \"cursorclass\": pymysql.cursors.DictCursor,\n    }\n    return pymysql.connect(**config)\n</code></pre>"},{"location":"#crm.db.DB.execute_query","title":"<code>execute_query(query)</code>","text":"<p>Executes a SQL query and returns the results.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SQL query to execute.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: The result of the SQL query execution.</p> Source code in <code>crm/db.py</code> <pre><code>def execute_query(self, query: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Executes a SQL query and returns the results.\n\n    Args:\n        query (str): The SQL query to execute.\n\n    Returns:\n        List[Dict[str, Any]]: The result of the SQL query execution.\n    \"\"\"\n    with self.connection.cursor() as cursor:\n        cursor.execute(query)\n        return cursor.fetchall()\n</code></pre>"},{"location":"#crm.db.DB.load_config","title":"<code>load_config(path)</code>","text":"<p>Loads the database configuration from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path of the YAML configuration file.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing database configuration.</p> Source code in <code>crm/db.py</code> <pre><code>def load_config(self, path: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Loads the database configuration from a YAML file.\n\n    Args:\n        path (str): The file path of the YAML configuration file.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing database configuration.\n    \"\"\"\n    with open(path, \"r\") as file:\n        return yaml.safe_load(file)[\"database\"]\n</code></pre>"},{"location":"#crm.em","title":"<code>em</code>","text":"<p>Created on 2024-01-13</p> <p>@author: wf</p>"},{"location":"#crm.em.CRM","title":"<code>CRM</code>","text":"<p>CRM</p> Source code in <code>crm/em.py</code> <pre><code>class CRM:\n    \"\"\"\n    CRM\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @classmethod\n    def root_path(cls) -&gt; str:\n        \"\"\"\n        Get the root path dynamically based on the home directory.\n        \"\"\"\n        home = str(Path.home())\n        # Append the relative path to the home directory\n        root_path = f\"{home}/.smartcrm\"\n        return root_path\n</code></pre>"},{"location":"#crm.em.CRM.root_path","title":"<code>root_path()</code>  <code>classmethod</code>","text":"<p>Get the root path dynamically based on the home directory.</p> Source code in <code>crm/em.py</code> <pre><code>@classmethod\ndef root_path(cls) -&gt; str:\n    \"\"\"\n    Get the root path dynamically based on the home directory.\n    \"\"\"\n    home = str(Path.home())\n    # Append the relative path to the home directory\n    root_path = f\"{home}/.smartcrm\"\n    return root_path\n</code></pre>"},{"location":"#crm.em.EntityManager","title":"<code>EntityManager</code>","text":"<p>Generic Entity Manager</p> Source code in <code>crm/em.py</code> <pre><code>class EntityManager:\n    \"\"\"\n    Generic Entity Manager\n    \"\"\"\n\n    def __init__(self, entity_name: str, plural_name: str = None):\n        self.entity_name = entity_name\n        self.plural_name = plural_name if plural_name else f\"{entity_name.lower()}s\"\n        # Handling first letter uppercase for JSON keys\n        self.manager_name = (\n            self.entity_name[0].upper() + self.entity_name[1:] + \"Manager\"\n        )\n\n    def _convert_to_datetime(self, date_value: Any) -&gt; datetime:\n        \"\"\"\n        Convert a value to a datetime object.\n\n        Args:\n            date_str (Any): Date value to convert.\n\n        Returns:\n            datetime: A datetime object.\n        \"\"\"\n        if date_value is None:\n            return None\n        if isinstance(date_value, str):\n            date_str = date_value\n            parsed_date = datetime.fromisoformat(date_str) if date_str else None\n        else:\n            parsed_date = date_value\n        return parsed_date\n\n    def _convert_to_int(self, num_str: str) -&gt; int:\n        \"\"\"\n        Convert a string to an integer.\n\n        Args:\n            num_str (str): Numeric string to convert.\n\n        Returns:\n            int: An integer value.\n        \"\"\"\n        if num_str is None:\n            return None\n        try:\n            return int(num_str)\n        except ValueError:\n            return 0\n\n    def from_db(self, db: DB) -&gt; List[Dict]:\n        \"\"\"\n        Fetch entities from the database.\n\n        Args:\n            db (DB): Database object to execute queries.\n\n        Returns:\n            List[Dict]: A list of entity dictionaries.\n        \"\"\"\n        query = f\"SELECT * FROM {self.entity_name}\"\n        smartcrm_lod = db.execute_query(query)\n        lod = self.from_smartcrm(smartcrm_lod)\n        return lod\n\n    def from_json_file(self, json_path: str = None):\n        \"\"\"\n        read my lod from the given json_path\n        \"\"\"\n        if json_path is None:\n            json_path = f\"{CRM.root_path()}/{self.entity_name}.json\"\n\n        with open(json_path, \"r\") as json_file:\n            smartcrm_data = json.load(json_file)\n        # get the list of dicts\n        smartcrm_lod = smartcrm_data[self.manager_name][self.plural_name][\n            self.entity_name\n        ]\n        lod = self.from_smartcrm(smartcrm_lod)\n        return lod\n</code></pre>"},{"location":"#crm.em.EntityManager.from_db","title":"<code>from_db(db)</code>","text":"<p>Fetch entities from the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>DB</code> <p>Database object to execute queries.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of entity dictionaries.</p> Source code in <code>crm/em.py</code> <pre><code>def from_db(self, db: DB) -&gt; List[Dict]:\n    \"\"\"\n    Fetch entities from the database.\n\n    Args:\n        db (DB): Database object to execute queries.\n\n    Returns:\n        List[Dict]: A list of entity dictionaries.\n    \"\"\"\n    query = f\"SELECT * FROM {self.entity_name}\"\n    smartcrm_lod = db.execute_query(query)\n    lod = self.from_smartcrm(smartcrm_lod)\n    return lod\n</code></pre>"},{"location":"#crm.em.EntityManager.from_json_file","title":"<code>from_json_file(json_path=None)</code>","text":"<p>read my lod from the given json_path</p> Source code in <code>crm/em.py</code> <pre><code>def from_json_file(self, json_path: str = None):\n    \"\"\"\n    read my lod from the given json_path\n    \"\"\"\n    if json_path is None:\n        json_path = f\"{CRM.root_path()}/{self.entity_name}.json\"\n\n    with open(json_path, \"r\") as json_file:\n        smartcrm_data = json.load(json_file)\n    # get the list of dicts\n    smartcrm_lod = smartcrm_data[self.manager_name][self.plural_name][\n        self.entity_name\n    ]\n    lod = self.from_smartcrm(smartcrm_lod)\n    return lod\n</code></pre>"},{"location":"#crm.smart_crm","title":"<code>smart_crm</code>","text":"<p>Created on 2024-01-13</p> <p>@author: wf</p>"},{"location":"#crm.version","title":"<code>version</code>","text":"<p>Created on 2023-11-06</p> <p>@author: wf</p>"},{"location":"#crm.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>Version handling for niceSmartCRM</p> Source code in <code>crm/version.py</code> <pre><code>@dataclass\nclass Version:\n    \"\"\"\n    Version handling for niceSmartCRM\n    \"\"\"\n\n    name = \"niceSmartCRM\"\n    version = crm.__version__\n    date = \"2024-01-12\"\n    updated = \"2024-01-12\"\n    description = \"nicegui based Customer Relationship Management\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/niceSmartCRM\"\n    chat_url = \"https://github.com/BITPlan/niceSmartCRM/discussions\"\n    cm_url = \"https://github.com/BITPlan/niceSmartCRM\"\n\n    license = f\"\"\"Copyright 2024 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#crm.xmi","title":"<code>xmi</code>","text":"<p>Created on 2024-01-14</p> <p>@author: wf</p>"},{"location":"#crm.xmi.Class","title":"<code>Class</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ModelElement</code></p> Source code in <code>crm/xmi.py</code> <pre><code>@dataclass_json\n@dataclass\nclass Class(ModelElement):\n    is_abstract: Optional[str] = None\n    attributes: Dict[str, Attribute] = field(default_factory=dict)\n    operations: Dict[str, Operation] = field(default_factory=dict)\n    roles: Dict[str, Role] = field(default_factory=dict)\n\n    @classmethod\n    def from_xmi_dict(cls, parent: ModelElement, node: Dict) -&gt; \"Class\":\n        class_ = super().from_xmi_dict(parent, node)\n        class_.attributes={}\n        class_.operations={}\n        class_.roles={}\n        class_.is_abstract = node.get(\"@isAbstract\")\n        # Process attributes\n        for attr_list in node.get(\"attributes\", {}).values():\n            for attr in attr_list:\n                attribute = Attribute.from_xmi_dict(class_, attr)\n                class_.attributes[attribute.name] = attribute\n\n        # Process operations\n        for op_list in node.get('operations', {}).values():\n            if isinstance(op_list,dict):\n                op_list=[op_list]\n            for op in op_list:\n                operation = Operation.from_xmi_dict(class_, op)\n                class_.operations[operation.name] = operation\n\n        for role_list in node.get('roles', {}).values():\n            if isinstance(role_list,dict):\n                role_list=[role_list]\n            for role_node in role_list:\n                role=Role.from_xmi_dict(class_, role_node)\n                class_.roles[role.name] = role\n        return class_\n\n    def add_to_lookup(self, lookup: Dict):\n        super().add_to_lookup(lookup)  # Add the class itself\n        for attribute in self.attributes.values():  # Add all attributes\n            attribute.add_to_lookup(lookup)\n        for operation in self.operations.values():  # Add all operations\n            operation.add_to_lookup(lookup)\n        for role in self.roles.values():  # Add all roles\n            role.add_to_lookup(lookup)\n\n    def as_plantuml(self, indentation:str =\"\")-&gt;str:\n        \"\"\"\n        Generate PlantUML representation for this Class and its contents.\n\n        Args:\n            indentation (str): Indentation for the PlantUML code.\n\n        Returns:\n            str: The PlantUML representation for this Class and its contents.\n        \"\"\"\n        plantuml = f\"{indentation}class {self.short_name} {{\\n\"\n\n        # Add attributes\n        for _attr_name, attr in self.attributes.items():\n            attr_type=attr.type\n            if \"enum\" in attr_type:\n                attr_type=\"enum\"\n            # [[{{{attr.documentation}}} {attr.short_name} ]]\n            plantuml += f\"{indentation}  {attr.short_name}: {attr_type}\\n\"\n\n        # Add operations\n        for _op_name, op in self.operations.items():\n            operation_plantuml = op.as_plantuml(indentation + \"  \")\n            plantuml += f\"{operation_plantuml}\\n\"\n\n        plantuml += f\"{indentation}}}\\n\"\n        plantuml += f\"\"\"note top of {self.short_name}\n{self.multi_line_doc(40)}\nend note\n\"\"\"\n        return plantuml\n</code></pre>"},{"location":"#crm.xmi.Class.as_plantuml","title":"<code>as_plantuml(indentation='')</code>","text":"<p>Generate PlantUML representation for this Class and its contents.</p> <p>Parameters:</p> Name Type Description Default <code>indentation</code> <code>str</code> <p>Indentation for the PlantUML code.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The PlantUML representation for this Class and its contents.</p> Source code in <code>crm/xmi.py</code> <pre><code>    def as_plantuml(self, indentation:str =\"\")-&gt;str:\n        \"\"\"\n        Generate PlantUML representation for this Class and its contents.\n\n        Args:\n            indentation (str): Indentation for the PlantUML code.\n\n        Returns:\n            str: The PlantUML representation for this Class and its contents.\n        \"\"\"\n        plantuml = f\"{indentation}class {self.short_name} {{\\n\"\n\n        # Add attributes\n        for _attr_name, attr in self.attributes.items():\n            attr_type=attr.type\n            if \"enum\" in attr_type:\n                attr_type=\"enum\"\n            # [[{{{attr.documentation}}} {attr.short_name} ]]\n            plantuml += f\"{indentation}  {attr.short_name}: {attr_type}\\n\"\n\n        # Add operations\n        for _op_name, op in self.operations.items():\n            operation_plantuml = op.as_plantuml(indentation + \"  \")\n            plantuml += f\"{operation_plantuml}\\n\"\n\n        plantuml += f\"{indentation}}}\\n\"\n        plantuml += f\"\"\"note top of {self.short_name}\n{self.multi_line_doc(40)}\nend note\n\"\"\"\n        return plantuml\n</code></pre>"},{"location":"#crm.xmi.Model","title":"<code>Model</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Package</code></p> <p>Model with option to read from XMI files which have been converted to JSON</p> Source code in <code>crm/xmi.py</code> <pre><code>@dataclass_json\n@dataclass\nclass Model(Package):\n    \"\"\"\n    Model with option to read from\n    XMI files which have been converted to JSON\n    \"\"\"\n\n    @classmethod\n    def raw_read_xmi_json(cls, file_path: str) -&gt; Dict:\n        \"\"\"\n        read the XMI file which has been converted to JSON with xq\n\n        Args:\n            file_path (str): the file_path to read from\n        \"\"\"\n        with open(file_path, \"r\") as file:\n            data = json.load(file)\n        return data\n\n    @classmethod\n    def from_xmi_json(cls, file_path:str) -&gt; \"Model\":\n        \"\"\"\n        read the XMI file which has been converted to JSON with xq\n\n        Args:\n            file_path (str): the file_path to read from\n\n        Returns:\n            Model: the Model instance\n        \"\"\"\n        data = cls.raw_read_xmi_json(file_path)\n        model = cls.from_xmi_dict(None, data)\n        model.create_lookup()\n        return model\n\n    def create_lookup(self):\n        \"\"\"\n        create the lookup dict\n        \"\"\"\n        self.lookup={}\n        self.add_to_lookup(self.lookup)\n\n    def as_plantuml(self, indentation=\"\"):\n        plant_uml=super().as_plantuml(indentation)\n        for _model_id,element in self.lookup.items():\n\n            if isinstance(element,Role):\n                l_multi=\"\"\n                r_multi=\"\"\n                multi=element.multiplicity\n                if multi:\n                    multi_parts=multi.split(\"..\")\n                    if len(multi_parts)==2:\n                        l_multi,r_multi=multi_parts\n                        r_multi=f'\"{r_multi}\"'\n                    else:\n                        l_multi=multi_parts[0]\n                    l_multi=f'\"{l_multi}\"'\n\n                relation_plantuml = f\"{element.parent.short_name} {l_multi} -- {r_multi} {element.type} : {element.short_name}\"\n                plant_uml += f\"{indentation} {relation_plantuml}\\n\"\n        return plant_uml\n\n    def to_plant_uml(self) -&gt; str:\n        \"\"\"\n        Generate a PlantUML representation of the model.\n\n        Returns:\n            str: The PlantUML string.\n        \"\"\"\n        skinparams=\"\"\"\n' BITPlan Corporate identity skin params\n' Copyright (c) 2015-2024 BITPlan GmbH\n' see http://wiki.bitplan.com/PlantUmlSkinParams#BITPlanCI\n' skinparams generated by com.bitplan.restmodelmanager\nskinparam note {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam component {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam package {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam usecase {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam activity {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam classAttribute {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam interface {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam class {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam object {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nhide circle\n' end of skinparams '\"\"\"\n        plant_uml = \"@startuml\\n\"\n        plant_uml += f\"{skinparams}\\n\"\n        plant_uml += self.as_plantuml(\"\")\n        plant_uml += \"@enduml\"\n        return plant_uml\n</code></pre>"},{"location":"#crm.xmi.Model.create_lookup","title":"<code>create_lookup()</code>","text":"<p>create the lookup dict</p> Source code in <code>crm/xmi.py</code> <pre><code>def create_lookup(self):\n    \"\"\"\n    create the lookup dict\n    \"\"\"\n    self.lookup={}\n    self.add_to_lookup(self.lookup)\n</code></pre>"},{"location":"#crm.xmi.Model.from_xmi_json","title":"<code>from_xmi_json(file_path)</code>  <code>classmethod</code>","text":"<p>read the XMI file which has been converted to JSON with xq</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the file_path to read from</p> required <p>Returns:</p> Name Type Description <code>Model</code> <code>Model</code> <p>the Model instance</p> Source code in <code>crm/xmi.py</code> <pre><code>@classmethod\ndef from_xmi_json(cls, file_path:str) -&gt; \"Model\":\n    \"\"\"\n    read the XMI file which has been converted to JSON with xq\n\n    Args:\n        file_path (str): the file_path to read from\n\n    Returns:\n        Model: the Model instance\n    \"\"\"\n    data = cls.raw_read_xmi_json(file_path)\n    model = cls.from_xmi_dict(None, data)\n    model.create_lookup()\n    return model\n</code></pre>"},{"location":"#crm.xmi.Model.raw_read_xmi_json","title":"<code>raw_read_xmi_json(file_path)</code>  <code>classmethod</code>","text":"<p>read the XMI file which has been converted to JSON with xq</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the file_path to read from</p> required Source code in <code>crm/xmi.py</code> <pre><code>@classmethod\ndef raw_read_xmi_json(cls, file_path: str) -&gt; Dict:\n    \"\"\"\n    read the XMI file which has been converted to JSON with xq\n\n    Args:\n        file_path (str): the file_path to read from\n    \"\"\"\n    with open(file_path, \"r\") as file:\n        data = json.load(file)\n    return data\n</code></pre>"},{"location":"#crm.xmi.Model.to_plant_uml","title":"<code>to_plant_uml()</code>","text":"<p>Generate a PlantUML representation of the model.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The PlantUML string.</p> Source code in <code>crm/xmi.py</code> <pre><code>    def to_plant_uml(self) -&gt; str:\n        \"\"\"\n        Generate a PlantUML representation of the model.\n\n        Returns:\n            str: The PlantUML string.\n        \"\"\"\n        skinparams=\"\"\"\n' BITPlan Corporate identity skin params\n' Copyright (c) 2015-2024 BITPlan GmbH\n' see http://wiki.bitplan.com/PlantUmlSkinParams#BITPlanCI\n' skinparams generated by com.bitplan.restmodelmanager\nskinparam note {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam component {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam package {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam usecase {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam activity {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam classAttribute {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam interface {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam class {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam object {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nhide circle\n' end of skinparams '\"\"\"\n        plant_uml = \"@startuml\\n\"\n        plant_uml += f\"{skinparams}\\n\"\n        plant_uml += self.as_plantuml(\"\")\n        plant_uml += \"@enduml\"\n        return plant_uml\n</code></pre>"},{"location":"#crm.xmi.ModelElement","title":"<code>ModelElement</code>  <code>dataclass</code>","text":"<p>Base model element class</p> Source code in <code>crm/xmi.py</code> <pre><code>@dataclass_json\n@dataclass\nclass ModelElement:\n    \"\"\"\n    Base model element class\n    \"\"\"\n    name: str\n    id: str\n    stereotype: str\n    visibility: str\n    documentation: str\n    tagged_values: Dict[str, TaggedValue] = field(default_factory=dict)\n\n    @property\n    def short_name(self) -&gt; str:\n        \"\"\"\n        for name: Logical View::com::bitplan::smartCRM::Organisation::Name\n        return \"Name\"\n        \"\"\"\n        short_name=ModelElement.as_short_name(self.name)\n        return short_name\n\n    def multi_line_doc(self, limit: int) -&gt; str:\n        \"\"\"\n        Returns the documentation as a multiline string with a limited length per line.\n        Lines are broken at whitespace.\n\n        :param limit: The maximum length of each line.\n        :return: Multiline string.\n        \"\"\"\n        text='\\n'.join(textwrap.wrap(self.documentation, width=limit))\n        return text\n\n    def add_to_lookup(self,lookup:Dict):\n        lookup[self.id]=self\n\n    @classmethod\n    def as_short_name(cls,name:str)-&gt;str:\n        if name is None:\n            return None\n        short_name=name.split(\"::\")[-1]\n        return short_name\n\n    @classmethod\n    def from_xmi_dict(cls, parent: \"ModelElement\", node: Dict) -&gt; \"ModelElement\":\n        \"\"\"\n        Create a ModelElement instance from a dictionary.\n\n        Args:\n            parent (ModelElement): the parent ModelElement or None for the Model itself\n            node (Dict): A dictionary representing a ModelElement.\n\n        Returns:\n            ModelElement: An instance of ModelElement.\n        \"\"\"\n        element = cls(\n            name=node.get(\"@name\"),\n            id=node.get(\"@id\"),\n            stereotype=node.get(\"@stereotype\"),\n            visibility=node.get(\"@visibility\"),\n            documentation=node.get(\"Documentation\"),\n        )\n        element.parent=parent\n\n        for tv_list in node.get(\"taggedValues\", {}).values():\n            for tv in tv_list:\n                tagged_value = TaggedValue.from_xmi_dict(tv)\n                element.tagged_values[tagged_value.name] = tagged_value\n\n        return element\n\n    def as_plantuml(self, _indentation=\"\"):\n        return \"\"\n</code></pre>"},{"location":"#crm.xmi.ModelElement.short_name","title":"<code>short_name: str</code>  <code>property</code>","text":"<p>for name: Logical View::com::bitplan::smartCRM::Organisation::Name return \"Name\"</p>"},{"location":"#crm.xmi.ModelElement.from_xmi_dict","title":"<code>from_xmi_dict(parent, node)</code>  <code>classmethod</code>","text":"<p>Create a ModelElement instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>ModelElement</code> <p>the parent ModelElement or None for the Model itself</p> required <code>node</code> <code>Dict</code> <p>A dictionary representing a ModelElement.</p> required <p>Returns:</p> Name Type Description <code>ModelElement</code> <code>ModelElement</code> <p>An instance of ModelElement.</p> Source code in <code>crm/xmi.py</code> <pre><code>@classmethod\ndef from_xmi_dict(cls, parent: \"ModelElement\", node: Dict) -&gt; \"ModelElement\":\n    \"\"\"\n    Create a ModelElement instance from a dictionary.\n\n    Args:\n        parent (ModelElement): the parent ModelElement or None for the Model itself\n        node (Dict): A dictionary representing a ModelElement.\n\n    Returns:\n        ModelElement: An instance of ModelElement.\n    \"\"\"\n    element = cls(\n        name=node.get(\"@name\"),\n        id=node.get(\"@id\"),\n        stereotype=node.get(\"@stereotype\"),\n        visibility=node.get(\"@visibility\"),\n        documentation=node.get(\"Documentation\"),\n    )\n    element.parent=parent\n\n    for tv_list in node.get(\"taggedValues\", {}).values():\n        for tv in tv_list:\n            tagged_value = TaggedValue.from_xmi_dict(tv)\n            element.tagged_values[tagged_value.name] = tagged_value\n\n    return element\n</code></pre>"},{"location":"#crm.xmi.ModelElement.multi_line_doc","title":"<code>multi_line_doc(limit)</code>","text":"<p>Returns the documentation as a multiline string with a limited length per line. Lines are broken at whitespace.</p> <p>:param limit: The maximum length of each line. :return: Multiline string.</p> Source code in <code>crm/xmi.py</code> <pre><code>def multi_line_doc(self, limit: int) -&gt; str:\n    \"\"\"\n    Returns the documentation as a multiline string with a limited length per line.\n    Lines are broken at whitespace.\n\n    :param limit: The maximum length of each line.\n    :return: Multiline string.\n    \"\"\"\n    text='\\n'.join(textwrap.wrap(self.documentation, width=limit))\n    return text\n</code></pre>"},{"location":"#crm.xmi.Operation","title":"<code>Operation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ModelElement</code></p> Source code in <code>crm/xmi.py</code> <pre><code>@dataclass_json\n@dataclass\nclass Operation(ModelElement):\n    is_static: Optional[str] = None\n    is_abstract: Optional[str] = None\n    parameters: Dict[str, 'Parameter'] = field(default_factory=dict)\n\n    @classmethod\n    def from_xmi_dict(cls, parent: ModelElement, node: Dict) -&gt; 'Operation':\n        operation = super().from_xmi_dict(parent, node)\n        operation.parameters={}\n        operation.is_static = node.get('@isStatic')\n        operation.is_abstract = node.get('@isAbstract')\n\n        # Process parameters\n        for param_list in node.get('parameters', {}).values():\n            # return parameter\n            if isinstance(param_list,dict):\n                param_list=[param_list]\n            for param in param_list:\n                parameter = Parameter.from_xmi_dict(operation, param)\n                operation.parameters[parameter.name] = parameter\n\n        return operation\n\n    def as_plantuml(self, indentation=\"\")-&gt;str:\n        \"\"\"\n        Generate PlantUML representation for this Operation.\n\n        Args:\n            indentation (str): Indentation for the PlantUML code.\n\n        Returns:\n            str: The PlantUML representation for this Operation.\n        \"\"\"\n        plantuml = f\"{indentation}{self.short_name}(\"\n\n        # Add parameters\n        params = []\n        return_type=None\n        for param_name, param in self.parameters.items():\n            type_short=ModelElement.as_short_name(param.type)\n            if not param_name.endswith(\"::return\") and not param_name==\"return\":\n                param_str = f\"{param.short_name}: {type_short}\"\n                params.append(param_str)\n            else:\n                return_type=type_short\n\n        # Handle return type\n        if return_type:\n            params.append(f\"return: {return_type}\")\n        plantuml += \", \".join(params)\n        plantuml += \")\"\n        return plantuml\n</code></pre>"},{"location":"#crm.xmi.Operation.as_plantuml","title":"<code>as_plantuml(indentation='')</code>","text":"<p>Generate PlantUML representation for this Operation.</p> <p>Parameters:</p> Name Type Description Default <code>indentation</code> <code>str</code> <p>Indentation for the PlantUML code.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The PlantUML representation for this Operation.</p> Source code in <code>crm/xmi.py</code> <pre><code>def as_plantuml(self, indentation=\"\")-&gt;str:\n    \"\"\"\n    Generate PlantUML representation for this Operation.\n\n    Args:\n        indentation (str): Indentation for the PlantUML code.\n\n    Returns:\n        str: The PlantUML representation for this Operation.\n    \"\"\"\n    plantuml = f\"{indentation}{self.short_name}(\"\n\n    # Add parameters\n    params = []\n    return_type=None\n    for param_name, param in self.parameters.items():\n        type_short=ModelElement.as_short_name(param.type)\n        if not param_name.endswith(\"::return\") and not param_name==\"return\":\n            param_str = f\"{param.short_name}: {type_short}\"\n            params.append(param_str)\n        else:\n            return_type=type_short\n\n    # Handle return type\n    if return_type:\n        params.append(f\"return: {return_type}\")\n    plantuml += \", \".join(params)\n    plantuml += \")\"\n    return plantuml\n</code></pre>"},{"location":"#crm.xmi.Package","title":"<code>Package</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ModelElement</code></p> Source code in <code>crm/xmi.py</code> <pre><code>@dataclass_json\n@dataclass\nclass Package(ModelElement):\n    packages: Dict[str, \"Package\"] = field(default_factory=dict)\n    classes: Dict[str, \"Class\"] = field(default_factory=dict)\n\n    @classmethod\n    def from_xmi_dict(cls, parent: ModelElement, node: Dict) -&gt; \"Package\":\n        \"\"\"\n        Create a Package instance from a dictionary.\n\n        Args:\n            node (Dict): A dictionary representing a Package, with keys for package attributes.\n\n        Returns:\n            Package: An instance of Package.\n        \"\"\"\n        # top level package handling\n        if \"Package\" in node:\n            pnode = node[\"Package\"]\n        else:\n            pnode = node\n\n        package = super().from_xmi_dict(parent, pnode)\n        package.classes={}\n        package.packages={}\n        package.packages_by_name={}\n        # Process classes\n        for cl_list in pnode.get(\"classes\", {}).values():\n            for cl in cl_list:\n                class_ = Class.from_xmi_dict(package, cl)\n                package.classes[class_.name] = class_\n\n        # Process sub-packages\n        for sp in pnode.get(\"packages\", {}).values():\n            sub_package = Package.from_xmi_dict(package, sp)\n            package.packages[sub_package.id] = sub_package\n            package.packages_by_name[sub_package.name] = sub_package\n        return package\n\n    def add_to_lookup(self, lookup: Dict):\n        super().add_to_lookup(lookup)  # Add the package itself\n        for sub_package in self.packages.values():  # Add all sub-packages\n            sub_package.add_to_lookup(lookup)\n        for class_ in self.classes.values():  # Add all classes\n            class_.add_to_lookup(lookup)\n\n    def as_plantuml(self, indentation=\"\")-&gt;str:\n        \"\"\"\n        Generate PlantUML representation for this Package and its contents.\n\n        Args:\n            indentation (str): Indentation for the PlantUML code.\n\n        Returns:\n            str: The PlantUML representation for this Package and its contents.\n        \"\"\"\n        plantuml = f\"{indentation}package {self.short_name} {{\\n\"\n\n        # Add classes within the package\n        for _class_name, class_obj in self.classes.items():\n            class_plantuml = class_obj.as_plantuml(indentation + \"  \")\n            plantuml += f\"{class_plantuml}\\n\"\n\n        # Add sub-packages within the package\n        for _sub_package_name, sub_package_obj in self.packages.items():\n            sub_package_plantuml = sub_package_obj.as_plantuml(indentation + \"  \")\n            plantuml += f\"{sub_package_plantuml}\\n\"\n\n        plantuml += f\"{indentation}}}\\n\"\n        plantuml+=f\"\"\"note top of {self.short_name}\n{self.documentation}\nend note\n\"\"\"\n        return plantuml\n</code></pre>"},{"location":"#crm.xmi.Package.as_plantuml","title":"<code>as_plantuml(indentation='')</code>","text":"<p>Generate PlantUML representation for this Package and its contents.</p> <p>Parameters:</p> Name Type Description Default <code>indentation</code> <code>str</code> <p>Indentation for the PlantUML code.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The PlantUML representation for this Package and its contents.</p> Source code in <code>crm/xmi.py</code> <pre><code>    def as_plantuml(self, indentation=\"\")-&gt;str:\n        \"\"\"\n        Generate PlantUML representation for this Package and its contents.\n\n        Args:\n            indentation (str): Indentation for the PlantUML code.\n\n        Returns:\n            str: The PlantUML representation for this Package and its contents.\n        \"\"\"\n        plantuml = f\"{indentation}package {self.short_name} {{\\n\"\n\n        # Add classes within the package\n        for _class_name, class_obj in self.classes.items():\n            class_plantuml = class_obj.as_plantuml(indentation + \"  \")\n            plantuml += f\"{class_plantuml}\\n\"\n\n        # Add sub-packages within the package\n        for _sub_package_name, sub_package_obj in self.packages.items():\n            sub_package_plantuml = sub_package_obj.as_plantuml(indentation + \"  \")\n            plantuml += f\"{sub_package_plantuml}\\n\"\n\n        plantuml += f\"{indentation}}}\\n\"\n        plantuml+=f\"\"\"note top of {self.short_name}\n{self.documentation}\nend note\n\"\"\"\n        return plantuml\n</code></pre>"},{"location":"#crm.xmi.Package.from_xmi_dict","title":"<code>from_xmi_dict(parent, node)</code>  <code>classmethod</code>","text":"<p>Create a Package instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Dict</code> <p>A dictionary representing a Package, with keys for package attributes.</p> required <p>Returns:</p> Name Type Description <code>Package</code> <code>Package</code> <p>An instance of Package.</p> Source code in <code>crm/xmi.py</code> <pre><code>@classmethod\ndef from_xmi_dict(cls, parent: ModelElement, node: Dict) -&gt; \"Package\":\n    \"\"\"\n    Create a Package instance from a dictionary.\n\n    Args:\n        node (Dict): A dictionary representing a Package, with keys for package attributes.\n\n    Returns:\n        Package: An instance of Package.\n    \"\"\"\n    # top level package handling\n    if \"Package\" in node:\n        pnode = node[\"Package\"]\n    else:\n        pnode = node\n\n    package = super().from_xmi_dict(parent, pnode)\n    package.classes={}\n    package.packages={}\n    package.packages_by_name={}\n    # Process classes\n    for cl_list in pnode.get(\"classes\", {}).values():\n        for cl in cl_list:\n            class_ = Class.from_xmi_dict(package, cl)\n            package.classes[class_.name] = class_\n\n    # Process sub-packages\n    for sp in pnode.get(\"packages\", {}).values():\n        sub_package = Package.from_xmi_dict(package, sp)\n        package.packages[sub_package.id] = sub_package\n        package.packages_by_name[sub_package.name] = sub_package\n    return package\n</code></pre>"},{"location":"#crm.xmi.TaggedValue","title":"<code>TaggedValue</code>  <code>dataclass</code>","text":"Source code in <code>crm/xmi.py</code> <pre><code>@dataclass_json\n@dataclass\nclass TaggedValue:\n    name: str\n    value: Optional[str] = field(\n        default=None\n    )\n\n    @classmethod\n    def from_xmi_dict(cls, node: Dict) -&gt; \"TaggedValue\":\n        \"\"\"\n        Create a TaggedValue instance from a dictionary.\n\n        Args:\n            node (Dict): A dictionary representing a TaggedValue, with keys '@name' and 'Value'.\n\n        Returns:\n            TaggedValue: An instance of TaggedValue.\n        \"\"\"\n        name = node.get(\"@name\")\n        value = node.get(\"Value\")\n        return cls(name=name, value=value)\n</code></pre>"},{"location":"#crm.xmi.TaggedValue.from_xmi_dict","title":"<code>from_xmi_dict(node)</code>  <code>classmethod</code>","text":"<p>Create a TaggedValue instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Dict</code> <p>A dictionary representing a TaggedValue, with keys '@name' and 'Value'.</p> required <p>Returns:</p> Name Type Description <code>TaggedValue</code> <code>TaggedValue</code> <p>An instance of TaggedValue.</p> Source code in <code>crm/xmi.py</code> <pre><code>@classmethod\ndef from_xmi_dict(cls, node: Dict) -&gt; \"TaggedValue\":\n    \"\"\"\n    Create a TaggedValue instance from a dictionary.\n\n    Args:\n        node (Dict): A dictionary representing a TaggedValue, with keys '@name' and 'Value'.\n\n    Returns:\n        TaggedValue: An instance of TaggedValue.\n    \"\"\"\n    name = node.get(\"@name\")\n    value = node.get(\"Value\")\n    return cls(name=name, value=value)\n</code></pre>"}]}